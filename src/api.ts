/* tslint:disable */
/* eslint-disable */
/**
 * ZapCap API
 * API for generating amazing subtitles for your videos
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateVideoResponseDto
 */
export interface CreateVideoResponseDto {
    /**
     * 
     * @type {VideoStatusEnum}
     * @memberof CreateVideoResponseDto
     */
    'status': VideoStatusEnum;
    /**
     * Use this `id` to create a video task
     * @type {string}
     * @memberof CreateVideoResponseDto
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface CreateVideoTaskRequestDto
 */
export interface CreateVideoTaskRequestDto {
    /**
     * Template `id` gotten from Get Templates endpoint
     * @type {string}
     * @memberof CreateVideoTaskRequestDto
     */
    'templateId': string;
    /**
     * Optional flag to automatically approve the task upon creation. When set to true, the task is immediately marked as approved, allowing it to proceed to the next stage of processing without requiring manual approval. This is useful for workflows where immediate processing of the task is desired, bypassing the need for an explicit approval step.
     * @type {boolean}
     * @memberof CreateVideoTaskRequestDto
     */
    'autoApprove'?: boolean;
    /**
     * Providing this will copy the transcript from another task. This is useful for workflows where you want to use the same transcript for multiple rendering tasks. If the transcript\'s duration is longer than the video\'s duration, the transcript will be truncated. If the video\'s duration is longer, the video will not be truncated. It will simply be rendered without the subtitles beyond the provided transcript.
     * @type {string}
     * @memberof CreateVideoTaskRequestDto
     */
    'transcriptTaskId'?: string;
    /**
     * Language the subtitles should be in Valid languages: \'af\',\'am\',\'ar\',\'as\',\'az\',\'ba\',\'be\',\'bg\',\'bn\',\'bo\',\'br\',\'bs\',\'ca\',\'cs\',\'cy\',\'da\', \'de\',\'el\',\'en\',\'es\',\'et\',\'eu\',\'fa\',\'fi\',\'fo\',\'fr\',\'gl\',\'gu\',\'ha\',\'haw\',\'he\',\'hi\', \'hr\',\'ht\',\'hu\',\'hy\',\'id\',\'is\',\'it\',\'ja\',\'jw\',\'ka\',\'kk\',\'km\',\'kn\',\'ko\',\'la\',\'lb\', \'ln\',\'lo\',\'lt\',\'lv\',\'mg\',\'mi\',\'mk\',\'ml\',\'mn\',\'mr\',\'ms\',\'mt\',\'my\',\'ne\',\'nl\',\'nn\', \'no\',\'oc\',\'pa\',\'pl\',\'ps\',\'pt\',\'ro\',\'ru\',\'sa\',\'sd\',\'si\',\'sk\',\'sl\',\'sn\',\'so\',\'sq\', \'sr\',\'su\',\'sv\',\'sw\',\'ta\',\'te\',\'tg\',\'th\',\'tk\',\'tl\',\'tr\',\'tt\',\'uk\',\'ur\',\'uz\',\'vi\', \'yi\',\'yo\',\'zh\',\'yue\'
     * @type {string}
     * @memberof CreateVideoTaskRequestDto
     */
    'language'?: string;
    /**
     * Override render defaults. You are able to control various aspects of the subtitles using this property.
     * @type {RenderOptionsDto}
     * @memberof CreateVideoTaskRequestDto
     */
    'renderOptions'?: RenderOptionsDto;
    /**
     * Configure notifications on task status change. Refer to the [docs](https://platform.zapcap.ai/docs/webhooks/) for a complete overview.
     * @type {NotificationDto}
     * @memberof CreateVideoTaskRequestDto
     */
    'notification'?: NotificationDto;
    /**
     * This supports a \"Bring your own Transcription\" model. When this is supplied, the ZapCap API will not transcribe your video and instead use the provided value.
     * @type {Array<UpdateWordEntryDto>}
     * @memberof CreateVideoTaskRequestDto
     */
    'transcript'?: Array<UpdateWordEntryDto>;
}
/**
 * 
 * @export
 * @interface CreateVideoTaskResponseDto
 */
export interface CreateVideoTaskResponseDto {
    /**
     * `id` to use when querying the processing task\'s status in the Get Video Task endpoint
     * @type {string}
     * @memberof CreateVideoTaskResponseDto
     */
    'taskId': string;
}
/**
 * 
 * @export
 * @interface CreateVideoUploadRequestDto
 */
export interface CreateVideoUploadRequestDto {
    /**
     * 
     * @type {Array<UploadPartsDto>}
     * @memberof CreateVideoUploadRequestDto
     */
    'uploadParts': Array<UploadPartsDto>;
    /**
     * Name of the file
     * @type {string}
     * @memberof CreateVideoUploadRequestDto
     */
    'filename': string;
}
/**
 * 
 * @export
 * @interface CreateVideoUploadResponseDto
 */
export interface CreateVideoUploadResponseDto {
    /**
     * Upload id you will need to pass back to the ZapCap API when finalising the upload session.
     * @type {string}
     * @memberof CreateVideoUploadResponseDto
     */
    'uploadId': string;
    /**
     * Video id which will be used for subsequent requests when processing the video.
     * @type {string}
     * @memberof CreateVideoUploadResponseDto
     */
    'videoId': string;
    /**
     * Presigned upload URLs. You need to upload parts in the order the urls are returned in the array.
     * @type {Array<string>}
     * @memberof CreateVideoUploadResponseDto
     */
    'urls': Array<string>;
}
/**
 * 
 * @export
 * @interface GetVideoTaskResponseDto
 */
export interface GetVideoTaskResponseDto {
    /**
     * 
     * @type {VideoTaskStatusEnum}
     * @memberof GetVideoTaskResponseDto
     */
    'status': VideoTaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetVideoTaskResponseDto
     */
    'id': string;
    /**
     * Url to download the transcript. Link is valid for 1 hour.
     * @type {string}
     * @memberof GetVideoTaskResponseDto
     */
    'transcript': string | null;
    /**
     * Url to download the final file. Link is valid for 1 hour
     * @type {string}
     * @memberof GetVideoTaskResponseDto
     */
    'downloadUrl': string | null;
    /**
     * Whether the transcript has been approved.
     * @type {boolean}
     * @memberof GetVideoTaskResponseDto
     */
    'transcriptApproved'?: boolean;
    /**
     * Why the task failed
     * @type {string}
     * @memberof GetVideoTaskResponseDto
     */
    'error'?: string;
}


/**
 * 
 * @export
 * @interface HighlightOptionsDto
 */
export interface HighlightOptionsDto {
    /**
     * Random colour option one.
     * @type {string}
     * @memberof HighlightOptionsDto
     */
    'randomColourOne'?: string;
    /**
     * Random colour option two.
     * @type {string}
     * @memberof HighlightOptionsDto
     */
    'randomColourTwo'?: string;
    /**
     * Random colour option three.
     * @type {string}
     * @memberof HighlightOptionsDto
     */
    'randomColourThree'?: string;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * A generic recipient. Its behavior will change depending on the notification type. For webhooks, the recipient is expected to be a webhook endpoint accepting a POST request.  In the POST request, a signature will be sent which you can use to verify the authenticity of the message. Your webhook secret can be found on https://platform.zapcap.ai/dashboard/api-key.
     * @type {string}
     * @memberof NotificationDto
     */
    'recipient': string;
    /**
     * Specifies the type of notification to be sent. Currently, only webhook notifications are supported.
     * @type {string}
     * @memberof NotificationDto
     */
    'type': NotificationDtoTypeEnum;
    /**
     * Allows you to subscribe to task notifications for the chosen notification type.  You may select any combination of tasks. Once a corresponding task transitions to a terminal state, a notification will be sent.  Please note, if a task fails, a notification will be sent for only one of the events which was opted in to.
     * @type {Array<string>}
     * @memberof NotificationDto
     */
    'notificationsFor': Array<NotificationDtoNotificationsForEnum>;
}

export const NotificationDtoTypeEnum = {
    Webhook: 'webhook'
} as const;

export type NotificationDtoTypeEnum = typeof NotificationDtoTypeEnum[keyof typeof NotificationDtoTypeEnum];
export const NotificationDtoNotificationsForEnum = {
    Transcript: 'transcript',
    Render: 'render',
    RenderProgress: 'renderProgress'
} as const;

export type NotificationDtoNotificationsForEnum = typeof NotificationDtoNotificationsForEnum[keyof typeof NotificationDtoNotificationsForEnum];

/**
 * 
 * @export
 * @interface RenderOptionsDto
 */
export interface RenderOptionsDto {
    /**
     * This object controls the subtitle rows appearance and config.
     * @type {SubsOptionsDto}
     * @memberof RenderOptionsDto
     */
    'subsOptions'?: SubsOptionsDto;
    /**
     * This object controls the subtitles\' font and config.
     * @type {StyleOptionsDto}
     * @memberof RenderOptionsDto
     */
    'styleOptions'?: StyleOptionsDto;
    /**
     * This object controls the colouring option of important words
     * @type {HighlightOptionsDto}
     * @memberof RenderOptionsDto
     */
    'highlightOptions'?: HighlightOptionsDto;
}
/**
 * 
 * @export
 * @interface StyleOptionsDto
 */
export interface StyleOptionsDto {
    /**
     * The Y position of the subtitles, represented as a percentage of the video\'s height. The higher the value, the lower the subtitles will be on the video.
     * @type {number}
     * @memberof StyleOptionsDto
     */
    'top'?: number;
    /**
     * Whether the subtitles should be uppercased.
     * @type {boolean}
     * @memberof StyleOptionsDto
     */
    'fontUppercase'?: boolean;
    /**
     * Font size of subtitles.
     * @type {number}
     * @memberof StyleOptionsDto
     */
    'fontSize'?: number;
    /**
     * Font weight of subtitles. Refer to the numerical values for font-weight in css.
     * @type {number}
     * @memberof StyleOptionsDto
     */
    'fontWeight'?: number;
    /**
     * Base colour of subtitles.
     * @type {string}
     * @memberof StyleOptionsDto
     */
    'fontColor'?: string;
}
/**
 * 
 * @export
 * @interface SubsOptionsDto
 */
export interface SubsOptionsDto {
    /**
     * Whether to enable or disable emojis in the subtitles.
     * @type {boolean}
     * @memberof SubsOptionsDto
     */
    'emoji'?: boolean;
    /**
     * Whether the emoji\'s should be animated or not.
     * @type {boolean}
     * @memberof SubsOptionsDto
     */
    'emojiAnimation'?: boolean;
    /**
     * Whether the important words should be highlighted or not. Highlighted keywords can be coloured different or stand out in a specific manner depending on the template chosen. In most templates, the highlight keyword will be coloured randomly from from 3 colours which can be overridden using the `renderOptions.highlightOptions` object.
     * @type {boolean}
     * @memberof SubsOptionsDto
     */
    'emphasizeKeywords'?: boolean;
    /**
     * Whether the subtitles should be animated.
     * @type {boolean}
     * @memberof SubsOptionsDto
     */
    'animation'?: boolean;
    /**
     * Whether punctuation should be added to the subtitles.
     * @type {boolean}
     * @memberof SubsOptionsDto
     */
    'punctuation'?: boolean;
}
/**
 * 
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     * 
     * @type {string}
     * @memberof TemplateDto
     */
    'id': string;
    /**
     * Categories the template can be belongs to. Animated has animated emojis, highlighted has highlighted emphasis words, and basic has no emojis.
     * @type {Array<string>}
     * @memberof TemplateDto
     */
    'categories': Array<string>;
    /**
     * URL to the preview video of the template. The video is a 1 second preview of the template.
     * @type {string}
     * @memberof TemplateDto
     * @deprecated
     */
    'previewUrl': string;
    /**
     * 
     * @type {TemplateDtoPreviews}
     * @memberof TemplateDto
     */
    'previews': TemplateDtoPreviews;
}
/**
 * 
 * @export
 * @interface TemplateDtoPreviews
 */
export interface TemplateDtoPreviews {
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoPreviews
     */
    'previewMp4'?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateDtoPreviews
     */
    'previewGif'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWordEntryDto
 */
export interface UpdateWordEntryDto {
    /**
     * The subtitle text
     * @type {string}
     * @memberof UpdateWordEntryDto
     */
    'text': string;
    /**
     * Type of the entry
     * @type {string}
     * @memberof UpdateWordEntryDto
     */
    'type': string;
    /**
     * End time in seconds
     * @type {number}
     * @memberof UpdateWordEntryDto
     */
    'end_time': number;
    /**
     * Start time in seconds
     * @type {number}
     * @memberof UpdateWordEntryDto
     */
    'start_time': number;
    /**
     * Emoji representation of the word
     * @type {string}
     * @memberof UpdateWordEntryDto
     */
    'emoji'?: string | null;
    /**
     * Indicates if the word is important, and should be highlighted.
     * @type {boolean}
     * @memberof UpdateWordEntryDto
     */
    'important'?: boolean;
}
/**
 * 
 * @export
 * @interface UploadPartsDto
 */
export interface UploadPartsDto {
    /**
     * Size of part in bytes. Must be >= 5mb except for the last part. As a recommendation chunk your file by at least 10mb for performance.
     * @type {number}
     * @memberof UploadPartsDto
     */
    'contentLength': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VideoStatusEnum = {
    Todo: 'todo',
    Uploaded: 'uploaded',
    InProgress: 'inProgress',
    Aborted: 'aborted'
} as const;

export type VideoStatusEnum = typeof VideoStatusEnum[keyof typeof VideoStatusEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const VideoTaskStatusEnum = {
    Pending: 'pending',
    Transcribing: 'transcribing',
    TranscriptionCompleted: 'transcriptionCompleted',
    Rendering: 'rendering',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type VideoTaskStatusEnum = typeof VideoTaskStatusEnum[keyof typeof VideoTaskStatusEnum];


/**
 * 
 * @export
 * @interface VideoUploadByUrlRequestDto
 */
export interface VideoUploadByUrlRequestDto {
    /**
     * 
     * @type {string}
     * @memberof VideoUploadByUrlRequestDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WordEntryDto
 */
export interface WordEntryDto {
    /**
     * The subtitle text
     * @type {string}
     * @memberof WordEntryDto
     */
    'text': string;
    /**
     * Type of the entry
     * @type {string}
     * @memberof WordEntryDto
     */
    'type': string;
    /**
     * Confidence score for the word recognition
     * @type {number}
     * @memberof WordEntryDto
     */
    'confidence': number;
    /**
     * End time in seconds
     * @type {number}
     * @memberof WordEntryDto
     */
    'end_time': number;
    /**
     * Start time in seconds
     * @type {number}
     * @memberof WordEntryDto
     */
    'start_time': number;
    /**
     * Emoji representation of the word
     * @type {string}
     * @memberof WordEntryDto
     */
    'emoji'?: string | null;
    /**
     * Indicates if the word is important, and should be highlighted.
     * @type {boolean}
     * @memberof WordEntryDto
     */
    'important'?: boolean;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTranscript: async (videoId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('approveTranscript', 'videoId', videoId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveTranscript', 'id', id)
            const localVarPath = `/videos/{videoId}/task/{id}/approve-transcript`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('completeUpload', 'body', body)
            const localVarPath = `/videos/upload/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} videoId 
         * @param {CreateVideoTaskRequestDto} createVideoTaskRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (videoId: string, createVideoTaskRequestDto: CreateVideoTaskRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('createTask', 'videoId', videoId)
            // verify required parameter 'createVideoTaskRequestDto' is not null or undefined
            assertParamExists('createTask', 'createVideoTaskRequestDto', createVideoTaskRequestDto)
            const localVarPath = `/videos/{videoId}/task`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVideoTaskRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateVideoUploadRequestDto} createVideoUploadRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload: async (createVideoUploadRequestDto: CreateVideoUploadRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVideoUploadRequestDto' is not null or undefined
            assertParamExists('createUpload', 'createVideoUploadRequestDto', createVideoUploadRequestDto)
            const localVarPath = `/videos/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVideoUploadRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript: async (videoId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('getTranscript', 'videoId', videoId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTranscript', 'id', id)
            const localVarPath = `/videos/{videoId}/task/{id}/transcript`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoTask: async (videoId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('getVideoTask', 'videoId', videoId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVideoTask', 'id', id)
            const localVarPath = `/videos/{videoId}/task/{id}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {Array<UpdateWordEntryDto>} updateWordEntryDto Array of updated word entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscript: async (videoId: string, id: string, updateWordEntryDto: Array<UpdateWordEntryDto>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('updateTranscript', 'videoId', videoId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTranscript', 'id', id)
            // verify required parameter 'updateWordEntryDto' is not null or undefined
            assertParamExists('updateTranscript', 'updateWordEntryDto', updateWordEntryDto)
            const localVarPath = `/videos/{videoId}/task/{id}/transcript`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWordEntryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadVideo', 'file', file)
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VideoUploadByUrlRequestDto} videoUploadByUrlRequestDto URL of the video to upload. Mimetypes allowed: &#x60;video/mp4&#x60;, &#x60;video/quicktime&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideoByUrl: async (videoUploadByUrlRequestDto: VideoUploadByUrlRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoUploadByUrlRequestDto' is not null or undefined
            assertParamExists('uploadVideoByUrl', 'videoUploadByUrlRequestDto', videoUploadByUrlRequestDto)
            const localVarPath = `/videos/url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoUploadByUrlRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveTranscript(videoId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveTranscript(videoId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.approveTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeUpload(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeUpload(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.completeUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} videoId 
         * @param {CreateVideoTaskRequestDto} createVideoTaskRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(videoId: string, createVideoTaskRequestDto: CreateVideoTaskRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVideoTaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(videoId, createVideoTaskRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateVideoUploadRequestDto} createVideoUploadRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpload(createVideoUploadRequestDto: CreateVideoUploadRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVideoUploadResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUpload(createVideoUploadRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TemplateDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscript(videoId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscript(videoId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoTask(videoId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVideoTaskResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoTask(videoId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getVideoTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {Array<UpdateWordEntryDto>} updateWordEntryDto Array of updated word entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTranscript(videoId: string, id: string, updateWordEntryDto: Array<UpdateWordEntryDto>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTranscript(videoId, id, updateWordEntryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadVideo(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVideoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVideo(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VideoUploadByUrlRequestDto} videoUploadByUrlRequestDto URL of the video to upload. Mimetypes allowed: &#x60;video/mp4&#x60;, &#x60;video/quicktime&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadVideoByUrl(videoUploadByUrlRequestDto: VideoUploadByUrlRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVideoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVideoByUrl(videoUploadByUrlRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadVideoByUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTranscript(videoId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveTranscript(videoId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.completeUpload(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} videoId 
         * @param {CreateVideoTaskRequestDto} createVideoTaskRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(videoId: string, createVideoTaskRequestDto: CreateVideoTaskRequestDto, options?: any): AxiosPromise<CreateVideoTaskResponseDto> {
            return localVarFp.createTask(videoId, createVideoTaskRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateVideoUploadRequestDto} createVideoUploadRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(createVideoUploadRequestDto: CreateVideoUploadRequestDto, options?: any): AxiosPromise<CreateVideoUploadResponseDto> {
            return localVarFp.createUpload(createVideoUploadRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: any): AxiosPromise<Array<TemplateDto>> {
            return localVarFp.getTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript(videoId: string, id: string, options?: any): AxiosPromise<Array<WordEntryDto>> {
            return localVarFp.getTranscript(videoId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoTask(videoId: string, id: string, options?: any): AxiosPromise<GetVideoTaskResponseDto> {
            return localVarFp.getVideoTask(videoId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} videoId 
         * @param {string} id 
         * @param {Array<UpdateWordEntryDto>} updateWordEntryDto Array of updated word entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTranscript(videoId: string, id: string, updateWordEntryDto: Array<UpdateWordEntryDto>, options?: any): AxiosPromise<Array<WordEntryDto>> {
            return localVarFp.updateTranscript(videoId, id, updateWordEntryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideo(file: File, options?: any): AxiosPromise<CreateVideoResponseDto> {
            return localVarFp.uploadVideo(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VideoUploadByUrlRequestDto} videoUploadByUrlRequestDto URL of the video to upload. Mimetypes allowed: &#x60;video/mp4&#x60;, &#x60;video/quicktime&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadVideoByUrl(videoUploadByUrlRequestDto: VideoUploadByUrlRequestDto, options?: any): AxiosPromise<CreateVideoResponseDto> {
            return localVarFp.uploadVideoByUrl(videoUploadByUrlRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {string} videoId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public approveTranscript(videoId: string, id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).approveTranscript(videoId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public completeUpload(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completeUpload(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} videoId 
     * @param {CreateVideoTaskRequestDto} createVideoTaskRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTask(videoId: string, createVideoTaskRequestDto: CreateVideoTaskRequestDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTask(videoId, createVideoTaskRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateVideoUploadRequestDto} createVideoUploadRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createUpload(createVideoUploadRequestDto: CreateVideoUploadRequestDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createUpload(createVideoUploadRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTemplates(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} videoId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTranscript(videoId: string, id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTranscript(videoId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} videoId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVideoTask(videoId: string, id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVideoTask(videoId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} videoId 
     * @param {string} id 
     * @param {Array<UpdateWordEntryDto>} updateWordEntryDto Array of updated word entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateTranscript(videoId: string, id: string, updateWordEntryDto: Array<UpdateWordEntryDto>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateTranscript(videoId, id, updateWordEntryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadVideo(file: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadVideo(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideoUploadByUrlRequestDto} videoUploadByUrlRequestDto URL of the video to upload. Mimetypes allowed: &#x60;video/mp4&#x60;, &#x60;video/quicktime&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadVideoByUrl(videoUploadByUrlRequestDto: VideoUploadByUrlRequestDto, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadVideoByUrl(videoUploadByUrlRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



